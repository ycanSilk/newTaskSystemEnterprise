# 用户信息客户端加密缓存优化计划

## 1. 核心需求分析

### 1.1 用户需求

1. 通过middleware.ts将用户信息缓存到客户端浏览器的存储里
2. 使用useUser钩子来管理和获取用户信息
3. 用户信息在客户端存储时必须加密，防止通过F12查看具体字段名和信息
4. 修改前端页面，使用useUser钩子获取用户信息并渲染

### 1.2 现有架构

| 文件名                                           | 功能          | 当前实现              |
| --------------------------------------------- | ----------- | ----------------- |
| `src/middleware.ts`                           | Next.js 中间件 | 已实现路由加密解密和Token验证 |
| `src/hooks/useUser.ts`                        | 用户状态管理钩子    | 已实现，支持客户端缓存       |
| `src/app/publisher/profile/page.tsx`          | 发布者个人中心页面   | 已实现，使用静态数据        |
| `src/app/publisher/profile/settings/page.tsx` | 发布者设置页面     | 已实现，直接调用API       |

## 2. 优化计划

### 2.1 步骤 1：创建加密工具函数

**文件：** `src/lib/userEncryption.ts`
**操作：** 创建用于加密和解密用户信息的工具函数

### 2.2 步骤 2：修改useUser钩子

**文件：** `src/hooks/useUser.ts`
**操作：** 确保useUser钩子正确处理客户端加密缓存，支持从客户端存储获取加密的用户信息

### 2.3 步骤 3：修改middleware.ts

**文件：** `src/middleware.ts`
**操作：** 添加将用户信息加密缓存到客户端浏览器存储的逻辑

### 2.4 步骤 4：修改个人中心页面

**文件：** `src/app/publisher/profile/page.tsx`
**操作：** 使用useUser钩子获取用户信息并渲染到UI

### 2.5 步骤 5：修改设置页面

**文件：** `src/app/publisher/profile/settings/page.tsx`
**操作：** 删除API请求代码，使用useUser钩子获取用户信息并渲染

## 3. 实现细节

### 3.1 步骤 1：创建加密工具函数

**文件：** `src/lib/userEncryption.ts`
**操作：** 创建用于加密和解密用户信息的工具函数

**关键代码：**

```typescript
// 导入加密库
import CryptoJS from 'crypto-js';

// 加密密钥，实际项目中应该从环境变量获取
const ENCRYPTION_KEY = process.env.NEXT_PUBLIC_ENCRYPTION_KEY || 'your-encryption-key';

/**
 * 加密数据
 * @param data 要加密的数据
 * @returns 加密后的字符串
 */
export const encryptData = (data: any): string => {
  try {
    const jsonString = JSON.stringify(data);
    return CryptoJS.AES.encrypt(jsonString, ENCRYPTION_KEY).toString();
  } catch (error) {
    console.error('加密失败:', error);
    throw error;
  }
};

/**
 * 解密数据
 * @param encryptedData 要解密的字符串
 * @returns 解密后的数据
 */
export const decryptData = <T>(encryptedData: string): T => {
  try {
    const bytes = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
    const jsonString = bytes.toString(CryptoJS.enc.Utf8);
    return JSON.parse(jsonString) as T;
  } catch (error) {
    console.error('解密失败:', error);
    throw error;
  }
};
```

### 3.2 步骤 2：修改useUser钩子

**文件：** `src/hooks/useUser.ts`
**操作：** 确保useUser钩子支持从客户端存储获取加密的用户信息

**关键修改：**

```typescript
// 导入加密工具函数
import { encryptData, decryptData } from '@/lib/encryption';

// 从本地存储获取用户信息
const getUserFromLocalStorage = (): User | null => {
  try {
    if (typeof window === 'undefined') {
      return null;
    }
    
    const encryptedUserStr = localStorage.getItem(USER_STORAGE_KEY);
    if (encryptedUserStr) {
      // 解密用户信息
      const cachedUser = decryptData<CachedUser>(encryptedUserStr);
      // 检查缓存是否过期
      if (Date.now() - cachedUser.cachedAt > CACHE_EXPIRY_TIME) {
        localStorage.removeItem(USER_STORAGE_KEY);
        return null;
      }
      
      // 返回缓存的用户信息（不包含cachedAt字段）
      const { cachedAt, ...user } = cachedUser;
      return user as User;
    }
    return null;
  } catch (error) {
    console.error('Failed to get user from local storage:', error);
    localStorage.removeItem(USER_STORAGE_KEY);
    return null;
  }
};

// 保存用户信息到本地存储
const saveUserToCache = (user: User) => {
  try {
    if (typeof window === 'undefined') {
      return;
    }
    
    // 只缓存指定字段
    const cachedUser: CachedUser = {
      user_id: user.user_id || 0,
      username: user.username || '',
      email: user.email || '',
      phone: user.phone || null,
      organization_name: user.organization_name || '',
      organization_leader: user.organization_leader || '',
      role: user.role || '',
      token: user.token || '',
      cachedAt: Date.now(),
      // 兼容原有代码的字段
      id: user.id,
      status: user.status,
      createdAt: user.createdAt,
    };
    
    // 加密用户信息
    const encryptedUser = encryptData(cachedUser);
    localStorage.setItem(USER_STORAGE_KEY, encryptedUser);
  } catch (error) {
    console.error('Failed to save user to cache:', error);
  }
};
```

### 3.3 步骤 3：修改middleware.ts

**文件：** `src/middleware.ts`
**操作：** 添加将用户信息加密缓存到客户端浏览器存储的逻辑

**关键修改：**

```typescript
// 添加验证Token后的用户信息缓存逻辑
if (isValidToken) {
  // 调用获取用户信息的API
  const userInfoResponse = await fetch(`${origin}/api/auth/me`, {
    method: 'GET',
    credentials: 'include',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
    cache: 'no-store',
  });

  if (userInfoResponse.ok) {
    const userInfoResult = await userInfoResponse.json();
    if (userInfoResult.success && userInfoResult.data) {
      // 将用户信息通过响应头传递给客户端
      const response = NextResponse.next();
      // 加密用户信息后传递
      response.headers.set('X-User-Info', encryptData(userInfoResult.data));
      return response;
    }
  }
}
```

### 3.4 步骤 4：修改useUser钩子，添加从响应头获取加密用户信息的逻辑

**文件：** `src/hooks/useUser.ts`
**操作：** 添加从响应头获取加密用户信息并缓存到本地的逻辑

**关键修改：**

```typescript
// 添加从响应头获取用户信息的逻辑
useEffect(() => {
  // 尝试从响应头获取用户信息
  const getUserInfoFromHeaders = async () => {
    try {
      // 调用一个简单的API来获取包含用户信息的响应头
      const response = await fetch('/api/auth/me', {
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        cache: 'no-store',
      });

      if (response.ok) {
        const userInfoHeader = response.headers.get('X-User-Info');
        if (userInfoHeader) {
          // 解密用户信息
          const userInfo = decryptData<User>(userInfoHeader);
          // 更新状态和缓存
          setUser(userInfo);
          setIsLoggedIn(true);
          saveUserToCache(userInfo);
        }
      }
    } catch (error) {
      console.error('Failed to get user info from headers:', error);
    }
  };

  getUserInfoFromHeaders();
}, []);
```

### 3.5 步骤 5：修改个人中心页面

**文件：** `src/app/publisher/profile/page.tsx`
**操作：** 使用useUser钩子获取用户信息并渲染到UI

**关键修改：**

```typescript
// 导入useUser钩子
import { useUser } from '@/hooks/useUser';

// 使用useUser钩子获取用户信息
const { user } = useUser();

// 修改UI渲染
<div>
  <span className="flex font-bold text-lg items-center">
    {user?.organization_name || '测试组织'}
  </span>
  <span className="flex text-sm opacity-80">{user?.phone || '13800138000'}</span>
</div>
```

### 3.6 步骤 6：修改设置页面

**文件：** `src/app/publisher/profile/settings/page.tsx`
**操作：** 删除API请求代码，使用useUser钩子获取用户信息并渲染

**关键修改：**

```typescript
// 导入useUser钩子
import { useUser } from '@/hooks/useUser';

// 使用useUser钩子获取用户信息
const { user } = useUser();

// 修改UI渲染
{/* 名字 */}
<InfoItem label="名字" value={user?.username} field="name" placeholder="请输入名字" />

{/* 手机号 */}
<InfoItem label="手机号" value={user?.phone} field="phone" placeholder="请输入手机号" />

{/* 邮箱 */}
<InfoItem label="邮箱" value={user?.email || '未填写'} field="email" placeholder="请输入邮箱" />

{/* 企业名称 */}
<InfoItem label="企业名称" value={user?.organization_name || '未填写'} field="organization_name" placeholder="请输入企业名称" />

{/* 负责人 */}
<InfoItem label="负责人" value={user?.organization_leader || '未填写'} field="organization_leader" placeholder="请输入负责人姓名" />

// 删除账号类型和用户ID的展示代码
```

## 4. 预期效果

1. **安全性增强**：用户信息在客户端存储时是加密的，防止通过F12查看具体字段名和信息
2. **性能优化**：减少了前端页面的API请求，提高了页面加载速度
3. **用户体验提升**：页面加载更快，减少了加载状态的显示时间
4. **代码结构优化**：API调用逻辑集中在中间件，前端页面只负责渲染
5. **缓存管理**：用户信息通过useUser钩子统一管理，支持缓存过期和刷新

## 5. 技术栈

* Next.js 14.2.33

* React 18+

* TypeScript 5+

* 加密库：crypto-js

* 客户端缓存：localStorage

* 用户状态管理：useUser钩子

## 6. 测试计划

1. **功能测试**：验证middleware.ts是否正确将加密的用户信息缓存到客户端
2. **UI测试**：验证个人中心和设置页面是否正确渲染用户信息
3. **性能测试**：验证页面加载速度是否提高
4. **安全性测试**：验证通过F12无法查看用户信息的具体字段名和信息
5. **兼容性测试**：验证在不同浏览器中的表现

## 7. 风险评估

| 风险     | 影响                   | 缓解措施                   |
| ------ | -------------------- | ---------------------- |
| 加密密钥泄露 | 用户信息可被解密             | 将加密密钥存储在环境变量中，不在代码中硬编码 |
| 缓存过期   | 用户信息不新鲜              | 设置合理的缓存过期时间（1小时）       |
| 浏览器兼容性 | 某些浏览器不支持localStorage | 提供降级方案，如sessionStorage |
| 数据一致性  | 客户端缓存与服务器数据不一致       | 实现缓存刷新机制，定期从服务器获取最新数据  |
| 解密失败   | 用户信息无法读取             | 提供降级方案，重新从服务器获取用户信息    |

