# 登录状态校验优化计划 - 分层防御架构（含客户端缓存）

## 1. 项目目录架构分析

### 1.1 核心目录结构

```
src/
├── app/                    # Next.js App Router 路由
│   ├── api/                # API 路由（服务端）
│   │   └── auth/           # 认证相关 API
│   │       ├── login/      # 登录 API
│   │       ├── me/         # 获取当前用户信息 API
│   │       └── register/   # 注册 API
│   ├── publisher/          # 发布者相关页面
│   └── layout.tsx          # 根布局组件
├── components/             # 公共组件
│   ├── providers/          # 提供者组件
│   │   └── AuthGuard.tsx   # 路由守卫组件
│   └── ui/                 # UI 组件
├── hooks/                  # 自定义钩子
│   └── useUser.ts          # 用户状态管理钩子
├── lib/                    # 工具函数
│   ├── routeEncryption.ts  # 路由加密工具
│   └── utils.ts            # 通用工具函数
├── middleware.ts           # Next.js 中间件
└── types/                  # 类型定义
```

### 1.2 现有核心文件功能

| 文件名 | 功能 | 当前实现问题 |
|--------|------|--------------|
| `src/middleware.ts` | Next.js 中间件 | 可能未充分利用，未实现全局 Token 验证 |
| `src/hooks/useUser.ts` | 用户状态管理钩子 | 客户端频繁请求 `/api/auth/me`，可能导致多次不必要的请求 |
| `src/components/providers/AuthGuard.tsx` | 路由守卫组件 | 客户端渲染，依赖 `useUser` 钩子，可能存在安全隐患 |
| `src/app/publisher/dashboard/page.tsx` | 仪表盘页面 | 客户端渲染，重复验证登录状态 |
| `src/app/api/auth/me/route.ts` | 获取当前用户信息 API | 未优化，每次请求都需要查询数据库 |

## 2. 优化架构设计

### 2.1 分层防御策略

| 层 | 组件/机制 | 主要职责 | 优点 |
|---|-----------|----------|------|
| 第一层 (入口拦截) | 中间件 (`src/middleware.ts`) | 在请求到达页面前，校验 Token 有效性 | 全局性、高性能，避免不必要的页面渲染 |
| 第二层 (API 验证) | API 路由 (`src/app/api/auth/me/route.ts`) | 验证 Token 并返回用户信息 | 逻辑集中，易于维护和扩展 |
| 第三层 (客户端状态管理) | `useUser.ts` 钩子 + 客户端缓存 | 管理客户端用户状态，缓存用户信息到 localStorage | 减少 API 请求，提高页面加载速度 |
| 第四层 (路由守卫) | `AuthGuard.tsx` 组件 | 客户端路由守卫，处理未登录状态 | 客户端体验友好，避免白屏 |

### 2.2 优化核心原则

1. **利用现有资源**：充分利用已有的 `middleware.ts`、`useUser.ts`、`AuthGuard.tsx` 等文件，避免重复创建。
2. **符合目录架构**：所有新创建的文件都符合项目现有的目录架构。
3. **最小化修改**：只修改必要的文件，避免大规模重构。
4. **分层防御**：采用多层验证机制，提高安全性。
5. **性能优化**：减少不必要的 API 请求，提高页面加载速度。
6. **类型安全**：确保所有修改都符合 TypeScript 类型定义。

## 3. 优化计划

### 3.1 中间件优化 (`src/middleware.ts`)

**目标**：实现全局 Token 验证，减少不必要的页面渲染。

**实现内容**：
1. 配置中间件匹配路径，拦截所有 `/publisher/*` 请求。
2. 从 Cookie 中获取 Token，调用 API 验证 Token 有效性。
3. 对于有效 Token，将用户信息通过响应头传递给客户端。
4. 对于无效 Token，重定向到登录页。

**修改点**：
- 修改 `src/middleware.ts` 文件，实现全局 Token 验证。

### 3.2 API 路由优化 (`src/app/api/auth/me/route.ts`)

**目标**：优化获取用户信息 API，返回包含指定字段的用户信息。

**实现内容**：
1. 验证 Token 有效性。
2. 返回包含指定字段的用户信息：`token`、`user_id`、`username`、`email`、`phone`、`organization_name`、`organization_leader`。
3. 优化数据库查询，只查询必要的字段。

**修改点**：
- 修改 `src/app/api/auth/me/route.ts` 文件，返回包含指定字段的用户信息。

### 3.3 客户端缓存优化 (`src/hooks/useUser.ts`)

**目标**：优化 `useUser` 钩子，减少不必要的 API 请求，使用客户端缓存。

**实现内容**：
1. 将用户信息缓存到 localStorage，缓存键名：`task_system_user_cache`。
2. 缓存包含指定字段：`token`、`user_id`、`username`、`email`、`phone`、`organization_name`、`organization_leader`。
3. 实现缓存失效机制，基于 Token 过期时间或固定时间间隔。
4. 优化 API 请求逻辑：先检查缓存，缓存有效则直接使用，否则调用 API。
5. 实现防抖机制，减少短时间内的重复请求。

**修改点**：
- 修改 `src/hooks/useUser.ts` 文件，实现客户端缓存功能。

### 3.4 路由守卫优化 (`src/components/providers/AuthGuard.tsx`)

**目标**：简化 `AuthGuard` 组件逻辑，提高安全性。

**实现内容**：
1. 简化路由守卫逻辑，只处理未登录状态和加载状态。
2. 移除重复的登录状态验证，依赖 `useUser` 钩子。
3. 优化用户体验，添加加载动画。

**修改点**：
- 修改 `src/components/providers/AuthGuard.tsx` 文件，简化路由守卫逻辑。

### 3.5 页面组件优化 (`src/app/publisher/dashboard/page.tsx`)

**目标**：优化仪表盘页面，减少重复的登录状态验证。

**实现内容**：
1. 移除页面级的登录状态验证，依赖 `AuthGuard` 组件。
2. 简化页面逻辑，只处理业务逻辑。
3. 优化用户体验，添加加载动画。

**修改点**：
- 修改 `src/app/publisher/dashboard/page.tsx` 文件，移除重复的登录状态验证。

### 3.6 类型定义优化 (`src/types/user.ts`)

**目标**：优化用户类型定义，包含指定的字段。

**实现内容**：
1. 确保 `User` 类型包含所有必要的字段：`token`、`user_id`、`username`、`email`、`phone`、`organization_name`、`organization_leader`。
2. 优化类型定义，确保类型安全。

**修改点**：
- 修改 `src/types/user.ts` 文件，优化用户类型定义。

## 4. 实现步骤

### 4.1 第一步：类型定义优化

1. 修改 `src/types/user.ts` 文件，确保 `User` 类型包含所有必要的字段。

### 4.2 第二步：API 路由优化

1. 修改 `src/app/api/auth/me/route.ts` 文件，返回包含指定字段的用户信息。

### 4.3 第三步：中间件优化

1. 修改 `src/middleware.ts` 文件，实现全局 Token 验证。

### 4.4 第四步：客户端缓存优化

1. 修改 `src/hooks/useUser.ts` 文件，实现客户端缓存功能。

### 4.5 第五步：路由守卫优化

1. 修改 `src/components/providers/AuthGuard.tsx` 文件，简化路由守卫逻辑。

### 4.6 第六步：页面组件优化

1. 修改 `src/app/publisher/dashboard/page.tsx` 文件，移除重复的登录状态验证。

### 4.7 第七步：集成测试

1. 测试完整登录流程，验证缓存是否正确写入。
2. 测试未登录访问受保护页面，验证重定向功能。
3. 测试 Token 过期处理，验证缓存失效机制。
4. 测试多标签页登录状态同步，验证缓存更新功能。
5. 测试用户登出，验证缓存清除功能。

## 5. 预期效果

1. **安全性增强**：采用分层防御策略，提高系统安全性。
2. **性能优化**：减少不必要的 API 请求，提高页面加载速度。
3. **用户体验提升**：避免重复登录验证，流畅的页面跳转。
4. **代码可维护性**：逻辑集中，易于扩展和维护。
5. **符合目录架构**：所有修改都符合项目的目录架构。

## 6. 核心代码实现

### 6.1 中间件优化 (`src/middleware.ts`)

```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// 定义公共路径
const publicPaths = ['/publisher/auth/login', '/publisher/auth/register'];

// 定义需要保护的路径
const protectedPaths = ['/publisher'];

export async function middleware(request: NextRequest) {
  const path = request.nextUrl.pathname;
  
  // 检查是否为公共路径
  const isPublicPath = publicPaths.some(route => 
    path === route || path.startsWith(`${route}/`)
  );
  
  // 如果是公共路径，直接放行
  if (isPublicPath) {
    return NextResponse.next();
  }
  
  // 检查是否为需要保护的路径
  const isProtectedPath = protectedPaths.some(route => 
    path.startsWith(route)
  );
  
  // 如果不是需要保护的路径，直接放行
  if (!isProtectedPath) {
    return NextResponse.next();
  }
  
  try {
    // 从 Cookie 中获取 Token
    const token = request.cookies.get('token')?.value;
    
    // 如果没有 Token，重定向到登录页
    if (!token) {
      return NextResponse.redirect(new URL('/publisher/auth/login', request.url));
    }
    
    // 调用 API 验证 Token 有效性
    const response = await fetch(`${request.nextUrl.origin}/api/auth/me`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });
    
    // 如果 Token 无效，重定向到登录页
    if (response.status !== 200) {
      return NextResponse.redirect(new URL('/publisher/auth/login', request.url));
    }
    
    // Token 有效，放行
    return NextResponse.next();
  } catch (error) {
    // 发生错误，重定向到登录页
    return NextResponse.redirect(new URL('/publisher/auth/login', request.url));
  }
}

export const config = {
  matcher: ['/publisher/:path*'],
};
```

### 6.2 API 路由优化 (`src/app/api/auth/me/route.ts`)

```typescript
import { NextResponse } from 'next/server';
import { verifyToken } from '@/lib/utils';

// Mock 用户数据，实际应该从数据库中查询
const mockUser = {
  user_id: 1,
  username: 'testuser',
  email: 'test@example.com',
  phone: '13800138000',
  organization_name: '测试组织',
  organization_leader: '测试领导',
};

export async function GET(request: Request) {
  try {
    // 从请求头中获取 Token
    const authHeader = request.headers.get('Authorization');
    const token = authHeader?.replace('Bearer ', '');
    
    // 验证 Token 有效性
    if (!token || !verifyToken(token)) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    
    // 返回包含指定字段的用户信息
    return NextResponse.json({
      success: true,
      data: {
        ...mockUser,
        token,
      },
    });
  } catch (error) {
    return NextResponse.json({ success: false, message: 'Internal Server Error' }, { status: 500 });
  }
}
```

### 6.3 客户端缓存优化 (`src/hooks/useUser.ts`)

```typescript
'use client';

import { useState, useEffect, useRef } from 'react';
import { User } from '@/types';

// 本地存储键名
const USER_STORAGE_KEY = 'task_system_user_cache';
// 缓存过期时间（5分钟）
const CACHE_EXPIRY_TIME = 5 * 60 * 1000;

// 从本地存储获取缓存的用户信息
const getCachedUser = (): User | null => {
  try {
    const cachedStr = localStorage.getItem(USER_STORAGE_KEY);
    if (!cachedStr) return null;
    
    const cached = JSON.parse(cachedStr);
    const now = Date.now();
    
    // 检查缓存是否过期
    if (now - cached.cachedAt > CACHE_EXPIRY_TIME) {
      localStorage.removeItem(USER_STORAGE_KEY);
      return null;
    }
    
    // 返回缓存的用户信息，不包含 cachedAt 字段
    const { cachedAt, ...user } = cached;
    return user as User;
  } catch (error) {
    localStorage.removeItem(USER_STORAGE_KEY);
    return null;
  }
};

// 保存用户信息到本地存储
const saveUserToCache = (user: User) => {
  try {
    localStorage.setItem(USER_STORAGE_KEY, JSON.stringify({
      ...user,
      cachedAt: Date.now(),
    }));
  } catch (error) {
    console.error('Failed to cache user:', error);
  }
};

// 清除本地存储中的用户信息
const clearUserCache = () => {
  localStorage.removeItem(USER_STORAGE_KEY);
};

// 从API获取用户信息
const fetchUserFromApi = async (): Promise<User | null> => {
  try {
    const response = await fetch('/api/auth/me', {
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    if (response.status === 401) {
      clearUserCache();
      return null;
    }
    
    const data = await response.json();
    if (data.success && data.data) {
      // 保存用户信息到缓存
      saveUserToCache(data.data);
      return data.data;
    }
    
    clearUserCache();
    return null;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
};

export function useUser() {
  // 初始化时从缓存获取用户信息
  const [user, setUser] = useState<User | null>(getCachedUser);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoggedIn, setIsLoggedIn] = useState(!!getCachedUser());
  
  // 请求防抖定时器
  const debounceTimer = useRef<NodeJS.Timeout | null>(null);
  // 上次请求时间
  const lastRequestTime = useRef<number>(0);

  // 检查登录状态
  const checkLoginStatus = async () => {
    // 防抖：如果在1秒内已经请求过，跳过
    const now = Date.now();
    if (now - lastRequestTime.current < 1000) {
      return;
    }
    
    setIsLoading(true);
    lastRequestTime.current = now;
    
    try {
      const currentUser = await fetchUserFromApi();
      setUser(currentUser);
      setIsLoggedIn(!!currentUser);
    } catch (error) {
      setUser(null);
      setIsLoggedIn(false);
    } finally {
      setIsLoading(false);
    }
  };

  // 初始化时检查登录状态
  useEffect(() => {
    checkLoginStatus();
  }, []);

  // 监听页面可见性变化，当页面重新可见时检查登录状态
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        // 防抖：300ms内只执行一次
        if (debounceTimer.current) {
          clearTimeout(debounceTimer.current);
        }
        debounceTimer.current = setTimeout(() => {
          checkLoginStatus();
        }, 300);
      }
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
    };
  }, []);

  // 刷新用户信息
  const refreshUser = async () => {
    // 清除缓存，强制从API获取最新数据
    clearUserCache();
    await checkLoginStatus();
  };

  return {
    user,
    isLoading,
    isLoggedIn,
    refreshUser,
    isAuthenticated: isLoggedIn && !!user,
  };
}
```

### 6.4 路由守卫优化 (`src/components/providers/AuthGuard.tsx`)

```typescript
'use client';

import { ReactNode } from 'react';
import { useUser } from '@/hooks/useUser';
import { Loading } from '@/components/ui';

interface AuthGuardProps {
  children: ReactNode;
  requiredRole?: string;
  allowedRoles?: string[];
}

export const AuthGuard = ({ children, requiredRole, allowedRoles }: AuthGuardProps) => {
  const { user, isLoading, isAuthenticated } = useUser();

  // 加载状态：显示加载动画
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <Loading size="lg" />
          <p className="mt-4 text-gray-600">正在验证身份...</p>
        </div>
      </div>
    );
  }

  // 未登录状态：显示登录提示
  if (!isAuthenticated) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div className="bg-white rounded-lg shadow-xl p-8 max-w-md w-full mx-4">
          <h3 className="text-xl font-bold text-gray-800 mb-4 text-center">请先登录</h3>
          <p className="text-gray-600 mb-8 text-center">
            您尚未登录，无法访问该页面。请先登录账号。
          </p>
          <div className="flex justify-center">
            <button
              onClick={() => window.location.href = '/publisher/auth/login'}
              className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg transition-colors duration-200"
            >
              立即登录
            </button>
          </div>
        </div>
      </div>
    );
  }

  // 角色验证
  if (requiredRole && user?.role !== requiredRole) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <h3 className="text-xl font-bold text-gray-800 mb-4">权限不足</h3>
          <p className="text-gray-600">您没有权限访问该页面。</p>
        </div>
      </div>
    );
  }

  if (allowedRoles && user && !allowedRoles.includes(user.role)) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <h3 className="text-xl font-bold text-gray-800 mb-4">权限不足</h3>
          <p className="text-gray-600">您没有权限访问该页面。</p>
        </div>
      </div>
    );
  }

  // 已登录且角色验证通过：显示子组件
  return <>{children}</>;
};
```

### 6.5 页面组件优化 (`src/app/publisher/dashboard/page.tsx`)

```typescript
'use client';

import React, { useState, useEffect } from 'react';
import { useSearchParams } from 'next/navigation';
import OverViewTabPage from './OverView/page';
import ActiveTabPage from './InProgress/page';
import AwaitingReviewTabPage from './AwaitingReview/page';
import CompletedTabPage from './Completed/page';
import URLRedirection from '../../../components/promptBox/URLRedirection';
import { Loading } from '@/components/ui';

// 检查支付密码
const checkWalletPassword = async (setShowRedirectModal: React.Dispatch<React.SetStateAction<boolean>>, setIsCheckingPwd: React.Dispatch<React.SetStateAction<boolean>>) => {
  setIsCheckingPwd(true);
  try {
    const response = await fetch('/api/paymentWallet/checkWalletPwd', {
      credentials: 'include'
    });
    
    const result = await response.json();
    if (result.success && result.data && !result.data.has_password) {
      setShowRedirectModal(true);
    }
  } catch (error) {
    console.error('Failed to check wallet password:', error);
  } finally {
    setIsCheckingPwd(false);
  }
};

export default function PublisherDashboardPage() {
  const searchParams = useSearchParams();
  const tabFromUrl = searchParams?.get('tab') || 'OverView';
  const [activeTab, setActiveTab] = useState(tabFromUrl);
  const [showRedirectModal, setShowRedirectModal] = useState(false);
  const [isCheckingPwd, setIsCheckingPwd] = useState(false);

  // 确保页面加载时默认显示tab=OverView参数
  useEffect(() => {
    if (!searchParams?.has('tab')) {
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.set('tab', 'OverView');
      window.history.replaceState({}, '', newUrl.toString());
    }
  }, []);

  // 检查支付密码
  useEffect(() => {
    checkWalletPassword(setShowRedirectModal, setIsCheckingPwd);
  }, []);

  // 监听页面可见性变化，当页面重新可见时检查支付密码
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        checkWalletPassword(setShowRedirectModal, setIsCheckingPwd);
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);

  // 处理选项卡切换
  const handleTabChange = (tab: string) => {
    setActiveTab(tab);
    const newUrl = new URL(window.location.href);
    newUrl.searchParams.set('tab', tab);
    window.history.replaceState({}, '', newUrl.toString());
  };

  return (
    <div className="pb-20">
      {/* 选项卡切换按钮 */}
      <div className="mx-4 mt-4 grid grid-cols-4 gap-1">
        <button
          onClick={() => handleTabChange('OverView')}
          className={`py-3 px-2 rounded text-sm font-medium transition-colors ${activeTab === 'OverView' ? 'bg-blue-500 text-white shadow-md' : 'bg-white border border-gray-300 text-gray-600 hover:bg-blue-50'}`}
        >
          概览
        </button>
        <button
          onClick={() => handleTabChange('InProgress')}
          className={`py-3 px-2 rounded text-sm font-medium transition-colors ${activeTab === 'InProgress' ? 'bg-blue-500 text-white shadow-md' : 'bg-white border border-gray-300 text-gray-600 hover:bg-blue-50'}`}
        >
          进行中
        </button>
        <button
          onClick={() => handleTabChange('AwaitingReview')}
          className={`py-3 px-2 rounded text-sm font-medium transition-colors ${activeTab === 'AwaitingReview' ? 'bg-blue-500 text-white shadow-md' : 'bg-white border border-gray-300 text-gray-600 hover:bg-blue-50'}`}
        >
          待审核
        </button>
        <button
          onClick={() => handleTabChange('Completed')}
          className={`py-3 px-2 rounded text-sm font-medium transition-colors ${activeTab === 'Completed' ? 'bg-blue-500 text-white shadow-md' : 'bg-white border border-gray-300 text-gray-600 hover:bg-blue-50'}`}
        >
          已完成
        </button>
      </div>

      {/* 选项卡内容 */}
      {activeTab === 'OverView' && <OverViewTabPage />}
      {activeTab === 'InProgress' && <ActiveTabPage />}
      {activeTab === 'AwaitingReview' && <AwaitingReviewTabPage />}
      {activeTab === 'Completed' && <CompletedTabPage />}
      
      {/* URL重定向提示框 */}
      <URLRedirection
        isOpen={showRedirectModal}
        message="您尚未设置支付密码，请先设置支付密码"
        buttonText="前往设置"
        redirectUrl="/publisher/profile/paymentsettings/setpaymentpwd"
        onClose={() => setShowRedirectModal(false)}
      />
      
      {/* 支付密码检查加载状态 */}
      {isCheckingPwd && (
        <div className="fixed inset-0 bg-black bg-opacity-20 z-40 flex items-center justify-center">
          <Loading size="md" />
        </div>
      )}
    </div>
  );
}
```

## 7. 测试计划

### 7.1 功能测试

1. **登录流程测试**：
   - 输入正确的用户名和密码，验证是否成功登录。
   - 验证登录后是否正确跳转到仪表盘页面。
   - 验证登录状态是否正确缓存到 localStorage。

2. **未登录访问测试**：
   - 未登录状态下访问受保护页面，验证是否正确重定向到登录页。
   - 验证未登录状态下，AuthGuard 组件是否显示登录提示。

3. **Token 过期测试**：
   - 模拟 Token 过期，验证是否正确重定向到登录页。
   - 验证 Token 过期后，本地缓存是否正确清除。

4. **多标签页同步测试**：
   - 打开多个标签页，在一个标签页中登出，验证其他标签页是否正确同步登出状态。

5. **缓存测试**：
   - 验证用户信息是否正确缓存到 localStorage。
   - 验证缓存是否包含指定的字段。
   - 验证缓存是否在过期后正确更新。

### 7.2 性能测试

1. **页面加载时间测试**：
   - 测试优化前后页面的加载时间，验证是否有所提升。

2. **API 请求次数测试**：
   - 测试优化前后，页面加载时 `/api/auth/me` 的请求次数，验证是否有所减少。

3. **缓存命中率测试**：
   - 测试缓存的命中率，验证是否达到预期效果。

## 8. 部署计划

1. **代码审查**：
   - 对所有修改的代码进行审查，确保代码质量和安全性。

2. **测试环境部署**：
   - 将优化后的代码部署到测试环境，进行全面测试。

3. **生产环境部署**：
   - 在测试通过后，将优化后的代码部署到生产环境。

4. **监控和日志**：
   - 部署后，监控系统的运行情况，收集日志，及时发现和解决问题。

## 9. 风险评估

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 中间件性能影响 | 增加请求处理时间 | 优化中间件逻辑，减少不必要的计算和请求。 |
| 缓存一致性问题 | 客户端缓存与服务器数据不一致 | 实现合理的缓存过期机制，定期更新缓存。 |
| Token 安全问题 | Token 被窃取导致安全漏洞 | 使用 HTTPS，设置合理的 Token 过期时间，实现 Token 刷新机制。 |
| 浏览器兼容性问题 | 某些浏览器不支持 localStorage | 添加 localStorage 兼容性检查，降级处理。 |
| 代码复杂度增加 | 增加维护成本 | 保持代码简洁，添加必要的注释，遵循代码规范。 |

## 10. 结论

本优化计划充分利用了项目现有的目录架构和资源，采用分层防御策略，实现了登录状态的安全验证和高效缓存。通过优化中间件、API 路由、客户端缓存和路由守卫，减少了不必要的 API 请求，提高了页面加载速度，增强了系统的安全性和用户体验。

所有修改都符合项目的目录架构，最小化了对现有代码的影响，同时实现了显著的性能和安全提升。